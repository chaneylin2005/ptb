<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Booth Strip Viewer</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Montserrat:ital,wght@0,400;0,700;1,400&family=Pacifico&family=Pinyon+Script&display=swap" rel="stylesheet">
    
    <style>
        /* ==================== CSS CƠ BẢN ==================== */
        body { font-family: 'Montserrat', sans-serif; margin: 0; padding: 0; background-color: #f4f4f9; color: #333; }
        header { background-color: #007bff; color: white; padding: 20px; text-align: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        button, .primary-action, .secondary-action { border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; width: 100%; margin-top: 5px; }
        .primary-action { background-color: #28a745; color: white; font-size: 1.1em; margin-top: 20px; }
        .primary-action:hover { background-color: #1e7e34; }
        .secondary-action { background-color: #6c757d; color: white; }
        .secondary-action:hover { background-color: #5a6268; }
        .alert-message { background-color: #fff3cd; color: #856404; padding: 10px; border: 1px solid #ffeeba; border-radius: 4px; margin-bottom: 20px; text-align: center; }

        /* ==================== VIEW GỌN NHẸ ==================== */
        #viewer-container { max-width: 650px; margin: 20px auto; padding: 0 15px; text-align: center; }
        #photoStripCanvas { border: 5px dashed #ccc; background-color: white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); max-width: 100%; height: auto; display: block; margin: 20px auto; cursor: default; }
        .webcam-preview { margin-top: 20px; }
        #webcamFeed { width: 300px; height: auto; border: 2px solid #333; display: block; margin: 10px auto; }
        #viewerImageUploadLabel { text-align: center; margin-bottom: 5px; background-color: #17a2b8; color: white; display: block; }
        
    </style>
</head>
<body>

    <header>
        <h1 id="main-title">Sử Dụng Mẫu Photobooth</h1>
    </header>

    <div id="viewer-container">
        <h2 id="canvas-header">Khung Ảnh Strip Photobooth Của Bạn</h2>
        <canvas id="photoStripCanvas" width="600" height="1800">
            Trình duyệt của bạn không hỗ trợ Canvas.
        </canvas>
        <div class="webcam-preview">
            <video id="webcamFeed" autoplay></video>
            <button id="capturePhotoBtn" class="primary-action" style="background-color: #ffc107; color: #333; width: 100%; margin-top: 0;">Chụp Ảnh (1/4)</button>
            
            <label for="viewerImageUpload" id="viewerImageUploadLabel" class="secondary-action" style="margin-top: 5px;">
                **Hoặc Tải Ảnh Lên Để Thêm Sticker**
            </label>
            <input type="file" id="viewerImageUpload" accept="image/*" style="display: none;">
        </div>
        
        <button id="exportFinalImageBtn" class="primary-action">Xuất Strip Ảnh Hoàn Chỉnh (Tải về)</button>
        
        <div class="alert-message" style="margin-top: 20px;">
            Bạn có thể kéo, xoay, và thay đổi kích thước các đối tượng sticker/ảnh đã có và các ảnh mới tải lên. Nền Strip (không phải nền ảnh chụp) đã được kích hoạt.
        </div>
        
    </div>

    <footer>
        <p>&copy; 2025 Photo Booth Designer Của Bạn</p>
    </footer>

    <script>
        // --- HÀM HỖ TRỢ URL-SAFE BASE64 (SỬA LỖI VIEWER ATOM) ---
        function urlSafeBase64Decode(str) {
            str = str.replace(/-/g, '+').replace(/_/g, '/');
            // Thêm padding cho atob()
            while (str.length % 4) {
                str += '=';
            }
            return str;
        }
        // ------------------------------------------

        // --- KHAI BÁO BIẾN CHO VIEWER MODE ---
        const canvas = document.getElementById('photoStripCanvas');
        const ctx = canvas.getContext('2d');
        const webcamFeed = document.getElementById('webcamFeed');
        const capturePhotoBtn = document.getElementById('capturePhotoBtn');
        const exportFinalImageBtn = document.getElementById('exportFinalImageBtn');
        const viewerImageUpload = document.getElementById('viewerImageUpload');

        const MAX_PHOTOS = 4;
        let capturedPhotos = []; 
        let currentPhotoIndex = 0;
        let canvasObjects = []; 

        // --- BIẾN ĐIỀU KHIỂN THIẾT KẾ ---
        let isDragging = false;
        let isResizing = false;
        let isRotating = false; 
        let selectedObject = null;
        let startX;
        let startY;
        let lastAngle = 0; 
        
        let currentDesignId = null;
        let frameColor = '#000000';
        let frameThickness = 25;
        let photoSizeScale = 1.0;
        let stripWidth = 600;
        let stripHeight = 1800;
        
        // BIẾN NỀN MỚI
        let currentBackground = {
            type: 'color', 
            value: '#ffffff',
            imageObject: null 
        };
        
        
        // =======================================================
        // PHẦN 1: HÀM VẼ VÀ CHỤP ẢNH (ĐÃ FIX DRAW FRAME)
        // =======================================================

        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                webcamFeed.srcObject = stream;
                webcamFeed.style.display = 'block';
                capturePhotoBtn.style.display = 'block';
            } catch (error) {
                console.error("Không thể truy cập webcam:", error);
                webcamFeed.style.display = 'none';
                capturePhotoBtn.style.display = 'none';
                alert("Không thể truy cập Webcam. Vui lòng sử dụng tính năng 'Tải Ảnh Lên Để Thêm Sticker'.");
            }
        }
        
        function updateCaptureButtonText() {
            if (currentPhotoIndex < MAX_PHOTOS) {
                capturePhotoBtn.textContent = `Chụp Ảnh (${currentPhotoIndex + 1}/${MAX_PHOTOS})`;
                capturePhotoBtn.disabled = false;
            } else {
                capturePhotoBtn.textContent = `HOÀN TẤT CHỤP! (Sẵn sàng Xuất Ảnh)`;
                capturePhotoBtn.disabled = true;
            }
        }

        function capturePhoto() {
            if (currentPhotoIndex >= MAX_PHOTOS) return;
            if (!webcamFeed.srcObject || webcamFeed.paused) {
                alert("Webcam chưa hoạt động hoặc bị tạm dừng. Vui lòng kiểm tra lại hoặc tải ảnh lên.");
                return;
            }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = webcamFeed.videoWidth;
            tempCanvas.height = webcamFeed.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(webcamFeed, 0, 0, tempCanvas.width, tempCanvas.height);
            
            const capturedImage = new Image();
            capturedImage.onload = () => {
                capturedPhotos[currentPhotoIndex] = { index: currentPhotoIndex, image: capturedImage, src: tempCanvas.toDataURL('image/png') };
                currentPhotoIndex++;
                updateCaptureButtonText();
                drawFrame(); 
            };
            capturedImage.onerror = (e) => {
                console.error("Lỗi khi tải ảnh đã chụp:", e);
                alert("Không thể xử lý ảnh đã chụp. Vui lòng thử lại.");
            };
            capturedImage.src = tempCanvas.toDataURL('image/png');
        }

        function exportFinalImage() {
            const tempSelectedObject = selectedObject;
            selectedObject = null;
            drawFrame(); 
            
            const imageURL = canvas.toDataURL("image/png");
            const link = document.createElement('a');
            link.download = `photobooth-strip-${currentDesignId || Date.now()}.png`;
            link.href = imageURL;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            selectedObject = tempSelectedObject;
            drawFrame();
        }


        // =======================================================
        // PHẦN 2: LOGIC VẼ KHUNG VÀ ĐỐI TƯỢNG (ĐÃ FIX BACKGROUND & XÓA NỀN TRẮNG ẢNH CHỤP)
        // =======================================================
        
        function drawFrame() {
            canvas.width = stripWidth;
            canvas.height = stripHeight;

            const photoWidth = stripWidth - 2 * frameThickness;
            const photoHeight = (stripHeight - (MAX_PHOTOS + 1) * frameThickness) / MAX_PHOTOS; 

            ctx.clearRect(0, 0, stripWidth, stripHeight);
            
            // 1. VẼ NỀN STRIP (COLOR/PATTERN/IMAGE)
            if (currentBackground.type === 'color') {
                ctx.fillStyle = currentBackground.value;
                ctx.fillRect(0, 0, stripWidth, stripHeight);
            } else if (currentBackground.type === 'pattern') {
                const patternCanvas = document.createElement('canvas');
                const patternSize = 50; 
                patternCanvas.width = patternSize;
                patternCanvas.height = patternSize;
                const patternCtx = patternCanvas.getContext('2d');
                
                if (currentBackground.value === 'none') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, stripWidth, stripHeight);
                } else if (currentBackground.value === 'dots') {
                    patternCtx.fillStyle = '#ccc'; patternCtx.fillRect(0, 0, patternSize, patternSize);
                    patternCtx.fillStyle = '#eee'; patternCtx.beginPath(); patternCtx.arc(patternSize/2, patternSize/2, 2, 0, Math.PI * 2); patternCtx.fill();
                } else if (currentBackground.value === 'lines') {
                    patternCtx.fillStyle = '#eee'; patternCtx.fillRect(0, 0, patternSize, patternSize);
                    patternCtx.strokeStyle = '#ccc'; patternCtx.lineWidth = 1; patternCtx.beginPath();
                    patternCtx.moveTo(0, patternSize / 2); patternCtx.lineTo(patternSize, patternSize / 2);
                    patternCtx.moveTo(patternSize / 2, 0); patternCtx.lineTo(patternSize / 2, patternSize); patternCtx.stroke();
                } else if (currentBackground.value === 'stripes') {
                     patternCtx.fillStyle = '#f0f0f0'; patternCtx.fillRect(0, 0, patternSize, patternSize);
                     patternCtx.fillStyle = '#ddd'; patternCtx.fillRect(0, 0, patternSize / 2, patternSize); 
                     patternCtx.fillRect(patternSize / 2, 0, patternSize / 2, patternSize);
                     patternCtx.rotate(45 * Math.PI / 180);
                }
                
                const pattern = ctx.createPattern(patternCanvas, 'repeat');
                ctx.fillStyle = pattern;
                ctx.fillRect(0, 0, stripWidth, stripHeight);

            } else if (currentBackground.type === 'image' && currentBackground.imageObject) {
                const img = currentBackground.imageObject;
                const ratio = Math.max(stripWidth / img.width, stripHeight / img.height);
                const drawW = img.width * ratio;
                const drawH = img.height * ratio;
                const drawX = (stripWidth - drawW) / 2;
                const drawY = (stripHeight - drawH) / 2;
                ctx.drawImage(img, drawX, drawY, drawW, drawH);
            }

            // 2. VẼ KHUNG VIỀN (Frame Color)
            ctx.fillStyle = frameColor;
            ctx.fillRect(0, 0, stripWidth, stripHeight);

            if (photoWidth <= 0 || photoHeight <= 0) {
                ctx.fillStyle = 'red';
                ctx.textAlign = 'center';
                ctx.font = '30px sans-serif';
                ctx.fillText('LỖI KÍCH THƯỚC KHUNG!', stripWidth / 2, stripHeight / 2);
                return;
            }
            
            // 3. VẼ các ô ảnh (Không còn nền trắng, ảnh chụp sẽ hiển thị trên nền strip)
            for (let i = 0; i < MAX_PHOTOS; i++) {
                const x = frameThickness;
                const y = frameThickness + i * (photoHeight + frameThickness); 

                // KHÔNG VẼ NỀN TRẮNG TẠI ĐÂY ĐỂ NỀN STRIP HIỂN THỊ
                // Nếu muốn vùng ảnh chụp là màu trắng, uncomment 2 dòng dưới
                // ctx.fillStyle = '#ffffff';
                // ctx.fillRect(x, y, photoWidth, photoHeight);

                if (capturedPhotos[i] && capturedPhotos[i].image) {
                    const img = capturedPhotos[i].image;
                    const imgAspectRatio = img.width / img.height;
                    const frameAspectRatio = photoWidth / photoHeight;

                    let finalDrawW, finalDrawH;
                    if (imgAspectRatio > frameAspectRatio) {
                        finalDrawH = photoHeight;
                        finalDrawW = photoHeight * imgAspectRatio;
                    } else {
                        finalDrawW = photoWidth;
                        finalDrawH = photoWidth / imgAspectRatio;
                    }

                    finalDrawW *= photoSizeScale;
                    finalDrawH *= photoSizeScale;

                    const drawX = x + (photoWidth - finalDrawW) / 2;
                    const drawY = y + (photoHeight - finalDrawH) / 2;
                    
                    // Cài đặt Clip Path để ảnh không tràn ra ngoài khung (rất quan trọng)
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(x, y, photoWidth, photoHeight);
                    ctx.clip(); // Giới hạn vùng vẽ

                    ctx.drawImage(img, drawX, drawY, finalDrawW, finalDrawH);
                    ctx.restore(); // Khôi phục Canvas

                } else {
                    ctx.fillStyle = 'gray';
                    ctx.font = '30px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Ảnh ${i + 1} CHƯA CHỤP`, x + photoWidth / 2, y + photoHeight / 2);
                }
            }
            
            // 4. VẼ CÁC STICKER/TEXT
            canvasObjects.forEach(obj => {
                ctx.save();
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(obj.angle || 0); 
                ctx.translate(-centerX, -centerY); 

                if (obj.type === 'image' || obj.type === 'sticker') {
                    if (obj.image && obj.image.complete) { 
                        ctx.drawImage(obj.image, obj.x, obj.y, obj.width, obj.height);
                    }
                } else if (obj.type === 'text') {
                    ctx.font = `${obj.fontSize}px "${obj.fontFamily}", sans-serif`;
                    ctx.fillStyle = obj.textColor;
                    ctx.textAlign = 'center'; 
                    ctx.textBaseline = 'middle'; 
                    
                    const metrics = ctx.measureText(obj.text);
                    obj.width = metrics.width;
                    obj.height = obj.fontSize * 1.2; 
                    
                    ctx.fillText(obj.text, obj.x + obj.width / 2, obj.y + obj.height / 2); 
                }
                
                // VẼ VIỀN VÀ ĐIỂM ĐIỀU KHIỂN NẾU ĐƯỢC CHỌN
                if (obj === selectedObject) {
                    const controlPointSize = 10;
                    ctx.strokeStyle = '#FF00FF'; 
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                    
                    ctx.fillStyle = '#00FFFF';
                    ctx.fillRect(obj.x + obj.width - controlPointSize / 2, obj.y + obj.height - controlPointSize / 2, controlPointSize, controlPointSize);
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(obj.x - controlPointSize / 2, obj.y - controlPointSize / 2, controlPointSize, controlPointSize);
                }
                ctx.restore(); 
            });
        }


        // =======================================================
        // PHẦN 3: LOGIC TƯƠNG TÁC (ĐÃ TỐI ƯU HÓA)
        // =======================================================
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) * (canvas.width / rect.width),
                y: (e.clientY - rect.top) * (canvas.height / rect.height)
            };
        }
        
        function isPointInObject(x, y, obj) {
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(-obj.angle || 0);
            const sin = Math.sin(-obj.angle || 0);
            
            const rotatedX = cos * (x - centerX) - sin * (y - centerY) + centerX;
            const rotatedY = sin * (x - centerX) + cos * (y - centerY) + centerY;

            return rotatedX >= obj.x && rotatedX <= obj.x + obj.width &&
                   rotatedY >= obj.y && rotatedY <= obj.y + obj.height;
        }

        function checkRotatedHandle(x, y, obj, handleType) {
            const controlPointSize = 10;
            let handleX, handleY;

            if (handleType === 'resize') {
                handleX = obj.x + obj.width - controlPointSize / 2;
                handleY = obj.y + obj.height - controlPointSize / 2;
            } else if (handleType === 'rotate') {
                handleX = obj.x - controlPointSize / 2;
                handleY = obj.y - controlPointSize / 2;
            } else {
                return false;
            }

            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;

            const cos = Math.cos(-obj.angle || 0);
            const sin = Math.sin(-obj.angle || 0);

            const rotatedMouseX = cos * (x - centerX) - sin * (y - centerY) + centerX;
            const rotatedMouseY = sin * (x - centerX) + cos * (y - centerY) + centerY;
            
            return rotatedMouseX >= handleX - 5 && rotatedMouseX <= handleX + controlPointSize + 5 &&
                   rotatedMouseY >= handleY - 5 && rotatedMouseY <= handleY + controlPointSize + 5;
        }

        function isPointInResizeHandle(x, y, obj) {
            return checkRotatedHandle(x, y, obj, 'resize');
        }

        function isPointInRotateHandle(x, y, obj) {
            return checkRotatedHandle(x, y, obj, 'rotate');
        }

        function handleMouseDown(e) {
            const mousePos = getMousePos(e);
            let foundObject = null;
            isResizing = false;
            isRotating = false;
            if (e.button === 2) return; 
            
            selectedObject = null; 

            for (let i = canvasObjects.length - 1; i >= 0; i--) {
                const obj = canvasObjects[i];
                
                if (isPointInRotateHandle(mousePos.x, mousePos.y, obj)) {
                    selectedObject = obj;
                    isRotating = true;
                    isDragging = true; 
                    startX = mousePos.x;
                    startY = mousePos.y;
                    lastAngle = obj.angle || 0; 
                    drawFrame(); 
                    return;
                }

                if (isPointInResizeHandle(mousePos.x, mousePos.y, obj)) {
                    selectedObject = obj;
                    isResizing = true;
                    isDragging = true;
                    startX = mousePos.x;
                    startY = mousePos.y;
                    drawFrame();
                    return;
                }

                if (isPointInObject(mousePos.x, mousePos.y, obj)) {
                    foundObject = obj;
                    break;
                }
            }
            
            if (foundObject) {
                selectedObject = foundObject;
                isDragging = true;
                startX = mousePos.x;
                startY = mousePos.y;
                drawFrame(); 
            } else {
                selectedObject = null;
                drawFrame();
            }
        }

        function handleMouseMove(e) {
            if (!isDragging || !selectedObject) {
                return;
            }

            const mousePos = getMousePos(e);
            const dx = mousePos.x - startX;
            const dy = mousePos.y - startY;
            const obj = selectedObject;

            if (isResizing) {
                let newWidth = obj.width + dx;
                if (newWidth < 20) newWidth = 20; 

                if (obj.type === 'image' || obj.type === 'sticker') {
                    if (obj.image && obj.image.width > 0) {
                        const aspectRatio = obj.image.height / obj.image.width;
                        obj.width = newWidth;
                        obj.height = newWidth * aspectRatio;
                    }
                } else if (obj.type === 'text') {
                    let newSize = obj.fontSize + dy / 2; 
                    if (newSize < 10) newSize = 10;
                    obj.fontSize = newSize; 
                }
                
                startX = mousePos.x;
                startY = mousePos.y;

            } else if (isRotating) {
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                
                const currentAngle = Math.atan2(mousePos.y - centerY, mousePos.x - centerX);
                const startPointAngle = Math.atan2(startY - centerY, startX - centerX);
                
                obj.angle = currentAngle - startPointAngle + lastAngle;
                
            } else { // Kéo (Drag)
                obj.x += dx;
                obj.y += dy;
                
                startX = mousePos.x;
                startY = mousePos.y;
            }

            drawFrame();
        }

        function handleMouseUp() {
            if (isRotating && selectedObject) {
                lastAngle = selectedObject.angle || 0; 
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
        }

        // =======================================================
        // PHẦN 4: LOGIC TẢI DỮ LIỆU
        // =======================================================

        function loadDesignFromData(designData) {
            frameColor = designData.settings.frameColor || '#000000';
            frameThickness = parseInt(designData.settings.frameThickness) || 25;
            photoSizeScale = parseFloat(designData.settings.photoSizeScale) || 1.0;
            stripWidth = parseInt(designData.settings.stripWidth) || 600;
            stripHeight = parseInt(designData.settings.stripHeight) || 1800;
            currentDesignId = designData.id;
            
            // Tải thông tin Background 
            const bgSettings = designData.settings.background || { type: 'color', value: '#000000' };
            currentBackground.type = bgSettings.type;
            currentBackground.value = bgSettings.value;
            currentBackground.imageObject = null;
            
            const photosToLoadData = designData.photos || [];
            const objectsToLoadData = designData.objects || [];

            let loadCount = 0;
            let totalItemsToLoad = photosToLoadData.length + objectsToLoadData.length; 
            
            if (bgSettings.type === 'image' && bgSettings.value) {
                totalItemsToLoad++; 
                const img = new Image();
                img.onload = finishLoading; 
                img.onerror = finishLoading; 
                img.crossOrigin = "Anonymous";
                img.src = bgSettings.value;
                currentBackground.imageObject = img; // Gán đối tượng Image vào data object ngay lập tức
            }
            
            drawFrame(); 

            const finishLoading = () => {
                loadCount++;
                if (loadCount === totalItemsToLoad || totalItemsToLoad === 0) {
                    drawFrame(); 
                }
            };

            if (totalItemsToLoad === 0) finishLoading();

            // 1. Tải ảnh đã chụp/tải lên từ mẫu (capturedPhotos)
            photosToLoadData.forEach((photoData, index) => {
                if (photoData && photoData.src) {
                    const img = new Image();
                    img.onload = () => {
                        capturedPhotos[index] = { index: index, image: img, src: photoData.src };
                        currentPhotoIndex = Math.max(currentPhotoIndex, index + 1);
                        updateCaptureButtonText();
                        finishLoading();
                    };
                    img.onerror = () => {
                        capturedPhotos[index] = null; 
                        finishLoading();
                    };
                    img.crossOrigin = "Anonymous";
                    img.src = photoData.src;
                } else {
                    capturedPhotos[index] = null;
                    finishLoading();
                }
            });

            // 2. Tải Objects (Sticker/Text/Ảnh Idol)
            objectsToLoadData.forEach(objData => {
                if (objData.type === 'text') {
                    canvasObjects.push(objData);
                    finishLoading();
                } else if (objData.src) {
                    const img = new Image();
                    objData.image = img; 
                    canvasObjects.push(objData); 

                    img.onload = finishLoading;
                    img.onerror = () => {
                        console.error("Image loading failed for object:", objData.name);
                        finishLoading();
                    };
                    
                    img.crossOrigin = "Anonymous"; 
                    img.src = objData.src;
                } else {
                    finishLoading(); 
                }
            });
            
            startWebcam();
            updateCaptureButtonText();
        }

        // =======================================================
        // KHỞI TẠO VÀ GẮN SỰ KIỆN 
        // =======================================================

        window.onload = () => {
            const hashValueRaw = window.location.hash.substring(1);
            const hashValue = hashValueRaw.replace(/[^a-zA-Z0-9\-_=]/g, '').trim(); 
            const container = document.getElementById('viewer-container');
            
            if (!hashValue) {
                container.innerHTML = `<div class="alert-message">**LỖI:** Không tìm thấy dữ liệu mẫu thiết kế chia sẻ trong URL.</div>`;
                return;
            }

            try {
                const safeHashValue = urlSafeBase64Decode(hashValue);
                const base64Decoded = atob(safeHashValue); 
                const decodedJsonString = decodeURIComponent(escape(base64Decoded));
                const designData = JSON.parse(decodedJsonString);
                
                if (designData && designData.settings) {
                    loadDesignFromData(designData);
                } else {
                    throw new Error("Dữ liệu thiết kế không hợp lệ hoặc trống.");
                }

            } catch (e) {
                console.error("LỖI TẢI THIẾT KẾ CHIA SẺ:", e);
                container.innerHTML = `
                    <div class="alert-message">
                        **LỖI NGHIÊM TRỌNG (Dữ liệu hỏng):** Không thể tải mẫu thiết kế. Dữ liệu trong URL bị hỏng.
                        <p>Chi tiết: ${e.message}</p>
                        <p>Vui lòng yêu cầu người gửi tạo lại link chia sẻ mới.</p>
                    </div>
                `;
            }

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseout', handleMouseUp);
        };

        capturePhotoBtn.addEventListener('click', capturePhoto);
        exportFinalImageBtn.addEventListener('click', exportFinalImage);
        
        viewerImageUpload.addEventListener('change', (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                const file = files[0];
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const initialSize = 150;
                        
                        const newObject = {
                            type: 'sticker', 
                            image: img,
                            src: e.target.result,
                            x: (stripWidth / 2) - (initialSize / 2), 
                            y: (stripHeight / 2) - (initialSize / 2),
                            width: initialSize,
                            height: initialSize * (img.height / img.width),
                            angle: 0
                        };
                        
                        canvasObjects.push(newObject);
                        
                        selectedObject = newObject; 
                        drawFrame();
                        alert(`Ảnh mới đã được thêm vào dải ảnh. Bạn có thể kéo, thay đổi kích thước và xoay.`);
                    };
                    img.onerror = () => {
                        alert("Không thể tải ảnh bạn vừa chọn. Vui lòng thử lại với ảnh khác.");
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
    </script>
</body>
</html>